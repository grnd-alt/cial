// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: follows.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteFollower = `-- name: DeleteFollower :exec
DELETE FROM user_follows
WHERE follower_id = $1 AND followed_id = $2
`

type DeleteFollowerParams struct {
	FollowerID string
	FollowedID string
}

func (q *Queries) DeleteFollower(ctx context.Context, arg DeleteFollowerParams) error {
	_, err := q.db.Exec(ctx, deleteFollower, arg.FollowerID, arg.FollowedID)
	return err
}

const deleteSubscription = `-- name: DeleteSubscription :exec
DELETE FROM user_subscriptions
WHERE user_id = $1 AND subscription = $2
`

type DeleteSubscriptionParams struct {
	UserID       string
	Subscription []byte
}

func (q *Queries) DeleteSubscription(ctx context.Context, arg DeleteSubscriptionParams) error {
	_, err := q.db.Exec(ctx, deleteSubscription, arg.UserID, arg.Subscription)
	return err
}

const getAllFollowers = `-- name: GetAllFollowers :many
SELECT follower_id, followed_id, notification_type, followed_at
FROM user_follows
WHERE followed_id = $1 ORDER BY followed_at
`

func (q *Queries) GetAllFollowers(ctx context.Context, followedID string) ([]UserFollow, error) {
	rows, err := q.db.Query(ctx, getAllFollowers, followedID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserFollow
	for rows.Next() {
		var i UserFollow
		if err := rows.Scan(
			&i.FollowerID,
			&i.FollowedID,
			&i.NotificationType,
			&i.FollowedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllFollowing = `-- name: GetAllFollowing :many
SELECT follower_id, followed_id, notification_type, followed_at
FROM user_follows
WHERE follower_id = $1 ORDER BY followed_at
`

func (q *Queries) GetAllFollowing(ctx context.Context, followerID string) ([]UserFollow, error) {
	rows, err := q.db.Query(ctx, getAllFollowing, followerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserFollow
	for rows.Next() {
		var i UserFollow
		if err := rows.Scan(
			&i.FollowerID,
			&i.FollowedID,
			&i.NotificationType,
			&i.FollowedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowers = `-- name: GetFollowers :many
SELECT follower_id, followed_id, notification_type, followed_at
FROM user_follows
WHERE followed_id = $1 ORDER BY followed_at DESC LIMIT $2 OFFSET $3
`

type GetFollowersParams struct {
	FollowedID string
	Limit      int32
	Offset     int32
}

func (q *Queries) GetFollowers(ctx context.Context, arg GetFollowersParams) ([]UserFollow, error) {
	rows, err := q.db.Query(ctx, getFollowers, arg.FollowedID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserFollow
	for rows.Next() {
		var i UserFollow
		if err := rows.Scan(
			&i.FollowerID,
			&i.FollowedID,
			&i.NotificationType,
			&i.FollowedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowersCount = `-- name: GetFollowersCount :one
SELECT count(*)
FROM user_follows
WHERE followed_id = $1
`

func (q *Queries) GetFollowersCount(ctx context.Context, followedID string) (int64, error) {
	row := q.db.QueryRow(ctx, getFollowersCount, followedID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getFollowing = `-- name: GetFollowing :many
SELECT follower_id, followed_id, notification_type, followed_at
FROM user_follows
WHERE follower_id = $1 ORDER BY followed_at DESC LIMIT $2 OFFSET $3
`

type GetFollowingParams struct {
	FollowerID string
	Limit      int32
	Offset     int32
}

func (q *Queries) GetFollowing(ctx context.Context, arg GetFollowingParams) ([]UserFollow, error) {
	rows, err := q.db.Query(ctx, getFollowing, arg.FollowerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserFollow
	for rows.Next() {
		var i UserFollow
		if err := rows.Scan(
			&i.FollowerID,
			&i.FollowedID,
			&i.NotificationType,
			&i.FollowedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowingCount = `-- name: GetFollowingCount :one
SELECT count(*)
FROM user_follows
WHERE follower_id = $1
`

func (q *Queries) GetFollowingCount(ctx context.Context, followerID string) (int64, error) {
	row := q.db.QueryRow(ctx, getFollowingCount, followerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getSubscriptions = `-- name: GetSubscriptions :many
SELECT subscription
FROM user_subscriptions
WHERE user_id = $1
`

func (q *Queries) GetSubscriptions(ctx context.Context, userID string) ([][]byte, error) {
	rows, err := q.db.Query(ctx, getSubscriptions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][]byte
	for rows.Next() {
		var subscription []byte
		if err := rows.Scan(&subscription); err != nil {
			return nil, err
		}
		items = append(items, subscription)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertFollower = `-- name: InsertFollower :exec
INSERT INTO user_follows(follower_id, followed_id, notification_type)
VALUES ($1, $2, $3) ON CONFLICT (follower_id, followed_id) DO NOTHING
`

type InsertFollowerParams struct {
	FollowerID       string
	FollowedID       string
	NotificationType pgtype.Text
}

func (q *Queries) InsertFollower(ctx context.Context, arg InsertFollowerParams) error {
	_, err := q.db.Exec(ctx, insertFollower, arg.FollowerID, arg.FollowedID, arg.NotificationType)
	return err
}

const insertSubscription = `-- name: InsertSubscription :exec
INSERT INTO user_subscriptions (user_id, subscription)
VALUES ($1, $2) ON CONFLICT (subscription) DO UPDATE SET user_id=$1
`

type InsertSubscriptionParams struct {
	UserID       string
	Subscription []byte
}

func (q *Queries) InsertSubscription(ctx context.Context, arg InsertSubscriptionParams) error {
	_, err := q.db.Exec(ctx, insertSubscription, arg.UserID, arg.Subscription)
	return err
}

const isFollowing = `-- name: IsFollowing :one
SELECT EXISTS (
    SELECT 1
    FROM user_follows
    WHERE follower_id = $1 AND followed_id = $2
)
`

type IsFollowingParams struct {
	FollowerID string
	FollowedID string
}

func (q *Queries) IsFollowing(ctx context.Context, arg IsFollowingParams) (bool, error) {
	row := q.db.QueryRow(ctx, isFollowing, arg.FollowerID, arg.FollowedID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
