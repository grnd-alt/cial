// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const findUser = `-- name: FindUser :many
SELECT users.user_id, users.username FROM users WHERE username LIKE '%' || $1 || '%' LIMIT 10
`

type FindUserRow struct {
	UserID   string
	Username string
}

func (q *Queries) FindUser(ctx context.Context, dollar_1 pgtype.Text) ([]FindUserRow, error) {
	rows, err := q.db.Query(ctx, findUser, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindUserRow
	for rows.Next() {
		var i FindUserRow
		if err := rows.Scan(&i.UserID, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNoLoggedInSince = `-- name: GetNoLoggedInSince :many
SELECT id, user_id, username, last_login, last_notified FROM users WHERE last_login < $1 limit $2
`

type GetNoLoggedInSinceParams struct {
	LastLogin pgtype.Timestamptz
	Limit     int32
}

func (q *Queries) GetNoLoggedInSince(ctx context.Context, arg GetNoLoggedInSinceParams) ([]User, error) {
	rows, err := q.db.Query(ctx, getNoLoggedInSince, arg.LastLogin, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Username,
			&i.LastLogin,
			&i.LastNotified,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserById = `-- name: GetUserById :one
SELECT id, user_id, username, last_login, last_notified FROM users WHERE user_id = $1
`

func (q *Queries) GetUserById(ctx context.Context, userID string) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, userID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Username,
		&i.LastLogin,
		&i.LastNotified,
	)
	return i, err
}

const getUserByName = `-- name: GetUserByName :one
SELECT id, user_id, username, last_login, last_notified FROM users WHERE username = $1
`

func (q *Queries) GetUserByName(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByName, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Username,
		&i.LastLogin,
		&i.LastNotified,
	)
	return i, err
}

const insertUser = `-- name: InsertUser :exec
INSERT INTO users (username, user_id) VALUES ($1, $2) ON CONFLICT (user_id) DO UPDATE set username = EXCLUDED.username where users.username <> EXCLUDED.username
`

type InsertUserParams struct {
	Username string
	UserID   string
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) error {
	_, err := q.db.Exec(ctx, insertUser, arg.Username, arg.UserID)
	return err
}

const setLastLogin = `-- name: SetLastLogin :exec
UPDATE users SET last_login = now() WHERE user_id = $1
`

func (q *Queries) SetLastLogin(ctx context.Context, userID string) error {
	_, err := q.db.Exec(ctx, setLastLogin, userID)
	return err
}

const setLastNotified = `-- name: SetLastNotified :exec
UPDATE users SET last_notified = now() WHERE user_id = $1
`

func (q *Queries) SetLastNotified(ctx context.Context, userID string) error {
	_, err := q.db.Exec(ctx, setLastNotified, userID)
	return err
}
