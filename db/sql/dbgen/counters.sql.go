// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: counters.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addEventToCounter = `-- name: AddEventToCounter :exec
INSERT INTO counters_users_events (user_id, counter_id) VALUES ($1, $2)
`

type AddEventToCounterParams struct {
	UserID    string
	CounterID int32
}

func (q *Queries) AddEventToCounter(ctx context.Context, arg AddEventToCounterParams) error {
	_, err := q.db.Exec(ctx, addEventToCounter, arg.UserID, arg.CounterID)
	return err
}

const addUserToCounter = `-- name: AddUserToCounter :exec
INSERT INTO counters_users (user_id, counter_id, token, access_type) VALUES ( $1, $2, $3, $4)
`

type AddUserToCounterParams struct {
	UserID     string
	CounterID  int32
	Token      pgtype.Text
	AccessType pgtype.Text
}

func (q *Queries) AddUserToCounter(ctx context.Context, arg AddUserToCounterParams) error {
	_, err := q.db.Exec(ctx, addUserToCounter,
		arg.UserID,
		arg.CounterID,
		arg.Token,
		arg.AccessType,
	)
	return err
}

const createCounter = `-- name: CreateCounter :one
INSERT INTO counters (name, icon) VALUES ( $1, $2 ) RETURNING id, name, icon
`

type CreateCounterParams struct {
	Name pgtype.Text
	Icon pgtype.Text
}

func (q *Queries) CreateCounter(ctx context.Context, arg CreateCounterParams) (Counter, error) {
	row := q.db.QueryRow(ctx, createCounter, arg.Name, arg.Icon)
	var i Counter
	err := row.Scan(&i.ID, &i.Name, &i.Icon)
	return i, err
}

const getCounter = `-- name: GetCounter :one
SELECT 
    counters.id, counters.name, counters.icon
FROM 
    counters
WHERE 
    counters.id = $1
`

func (q *Queries) GetCounter(ctx context.Context, id int32) (Counter, error) {
	row := q.db.QueryRow(ctx, getCounter, id)
	var i Counter
	err := row.Scan(&i.ID, &i.Name, &i.Icon)
	return i, err
}

const getCounterEventsForUser = `-- name: GetCounterEventsForUser :many
SELECT id, user_id, counter_id, created_at FROM counters_users_events where user_id = $1 limit $2
`

type GetCounterEventsForUserParams struct {
	UserID string
	Limit  int32
}

func (q *Queries) GetCounterEventsForUser(ctx context.Context, arg GetCounterEventsForUserParams) ([]CountersUsersEvent, error) {
	rows, err := q.db.Query(ctx, getCounterEventsForUser, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountersUsersEvent
	for rows.Next() {
		var i CountersUsersEvent
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CounterID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCountersForUser = `-- name: GetCountersForUser :many
SELECT DISTINCT
  counters.id, counters.name, counters.icon,
  counters_users.access_type,
  counters_users.entry_count,
  CASE WHEN latest_event.id IS NOT NULL THEN latest_event.id END as event_id,
  CASE WHEN latest_event.created_at IS NOT NULL THEN latest_event.created_at END as event_created_at
FROM counters
JOIN counters_users ON counters_users.counter_id = counters.id
LEFT JOIN (
  SELECT DISTINCT ON (counter_id) id, counter_id, user_id, created_at
  FROM counters_users_events
  WHERE counters_users_events.user_id = $1
  ORDER BY counter_id, id DESC
) latest_event ON latest_event.counter_id = counters.id
WHERE counters_users.user_id = $1
`

type GetCountersForUserRow struct {
	ID             int32
	Name           pgtype.Text
	Icon           pgtype.Text
	AccessType     pgtype.Text
	EntryCount     pgtype.Int4
	EventID        interface{}
	EventCreatedAt interface{}
}

func (q *Queries) GetCountersForUser(ctx context.Context, userID string) ([]GetCountersForUserRow, error) {
	rows, err := q.db.Query(ctx, getCountersForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCountersForUserRow
	for rows.Next() {
		var i GetCountersForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Icon,
			&i.AccessType,
			&i.EntryCount,
			&i.EventID,
			&i.EventCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvents = `-- name: GetEvents :many
SELECT id, user_id, counter_id, created_at from counters_users_events where user_id =$1 and counter_id = $2
`

type GetEventsParams struct {
	UserID    string
	CounterID int32
}

func (q *Queries) GetEvents(ctx context.Context, arg GetEventsParams) ([]CountersUsersEvent, error) {
	rows, err := q.db.Query(ctx, getEvents, arg.UserID, arg.CounterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountersUsersEvent
	for rows.Next() {
		var i CountersUsersEvent
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CounterID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserInCounter = `-- name: GetUserInCounter :one
SELECT DISTINCT id, user_id, counter_id, token, access_type, entry_count FROM counters_users where user_id = $1 and counter_id = $2
`

type GetUserInCounterParams struct {
	UserID    string
	CounterID int32
}

func (q *Queries) GetUserInCounter(ctx context.Context, arg GetUserInCounterParams) (CountersUser, error) {
	row := q.db.QueryRow(ctx, getUserInCounter, arg.UserID, arg.CounterID)
	var i CountersUser
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CounterID,
		&i.Token,
		&i.AccessType,
		&i.EntryCount,
	)
	return i, err
}

const getUsersInCounter = `-- name: GetUsersInCounter :many
SELECT DISTINCT counters_users.access_type, counters_users.entry_count, users.username from counters_users LEFT JOIN users on counters_users.user_id = users.user_id
where counters_users.counter_id = $1
`

type GetUsersInCounterRow struct {
	AccessType pgtype.Text
	EntryCount pgtype.Int4
	Username   pgtype.Text
}

func (q *Queries) GetUsersInCounter(ctx context.Context, counterID int32) ([]GetUsersInCounterRow, error) {
	rows, err := q.db.Query(ctx, getUsersInCounter, counterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersInCounterRow
	for rows.Next() {
		var i GetUsersInCounterRow
		if err := rows.Scan(&i.AccessType, &i.EntryCount, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
